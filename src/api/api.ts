/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.7
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import { kyMutator } from './client';
export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

export interface Category {
  id?: number;
  name?: string;
}

/**
 * pet status in the store
 */
export type PetStatus = (typeof PetStatus)[keyof typeof PetStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PetStatus = {
  available: 'available',
  pending: 'pending',
  sold: 'sold',
} as const;

export interface Pet {
  id?: number;
  category?: Category;
  name: string;
  photoUrls: string[];
  tags?: Tag[];
  /** pet status in the store */
  status?: PetStatus;
}

export interface Tag {
  id?: number;
  name?: string;
}

/**
 * Order Status
 */
export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderStatus = {
  placed: 'placed',
  approved: 'approved',
  delivered: 'delivered',
} as const;

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /** Order Status */
  status?: OrderStatus;
  complete?: boolean;
}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /** User Status */
  userStatus?: number;
}

/**
 * List of user object
 */
export type UserArrayBody = User[];

/**
 * Pet object that needs to be added to the store
 */
export type PetBody = Pet;

export type UploadFileBody = {
  /** Additional data to pass to server */
  additionalMetadata?: string;
  /** file to upload */
  file?: Blob;
};

export type FindPetsByStatusParams = {
  /**
   * Status values that need to be considered for filter
   */
  status: FindPetsByStatusStatusItem[];
};

export type FindPetsByStatusStatusItem =
  (typeof FindPetsByStatusStatusItem)[keyof typeof FindPetsByStatusStatusItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindPetsByStatusStatusItem = {
  available: 'available',
  pending: 'pending',
  sold: 'sold',
} as const;

export type FindPetsByTagsParams = {
  /**
   * Tags to filter by
   */
  tags: string[];
};

export type UpdatePetWithFormBody = {
  /** Updated name of the pet */
  name?: string;
  /** Updated status of the pet */
  status?: string;
};

export type GetInventory200 = { [key: string]: number };

export type LoginUserParams = {
  /**
   * The user name for login
   */
  username: string;
  /**
   * The password for login in clear text
   */
  password: string;
};

/**
 * @summary uploads an image
 */
export const uploadFile = (
  petId: number,
  uploadFileBody: UploadFileBody,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (uploadFileBody.additionalMetadata !== undefined) {
    formData.append(`additionalMetadata`, uploadFileBody.additionalMetadata);
  }
  if (uploadFileBody.file !== undefined) {
    formData.append(`file`, uploadFileBody.file);
  }

  return kyMutator<ApiResponse>({
    url: `/pet/${petId}/uploadImage`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  { petId: number; data: UploadFileBody },
  TContext
> => {
  const mutationKey = ['uploadFile'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFile>>,
    { petId: number; data: UploadFileBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return uploadFile(petId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadFile>>
>;
export type UploadFileMutationBody = UploadFileBody;
export type UploadFileMutationError = unknown;

/**
 * @summary uploads an image
 */
export const useUploadFile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadFile>>,
      TError,
      { petId: number; data: UploadFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  { petId: number; data: UploadFileBody },
  TContext
> => {
  const mutationOptions = getUploadFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Add a new pet to the store
 */
export const addPet = (petBody: PetBody, signal?: AbortSignal) => {
  return kyMutator<unknown>({
    url: `/pet`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: petBody,
    signal,
  });
};

export const getAddPetMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPet>>,
    TError,
    { data: PetBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addPet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationKey = ['addPet'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPet>>,
    { data: PetBody }
  > = (props) => {
    const { data } = props ?? {};

    return addPet(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddPetMutationResult = NonNullable<
  Awaited<ReturnType<typeof addPet>>
>;
export type AddPetMutationBody = PetBody;
export type AddPetMutationError = void;

/**
 * @summary Add a new pet to the store
 */
export const useAddPet = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addPet>>,
      TError,
      { data: PetBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addPet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationOptions = getAddPetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update an existing pet
 */
export const updatePet = (petBody: PetBody) => {
  return kyMutator<unknown>({
    url: `/pet`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: petBody,
  });
};

export const getUpdatePetMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePet>>,
    TError,
    { data: PetBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationKey = ['updatePet'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePet>>,
    { data: PetBody }
  > = (props) => {
    const { data } = props ?? {};

    return updatePet(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePetMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePet>>
>;
export type UpdatePetMutationBody = PetBody;
export type UpdatePetMutationError = void;

/**
 * @summary Update an existing pet
 */
export const useUpdatePet = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePet>>,
      TError,
      { data: PetBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationOptions = getUpdatePetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 */
export const findPetsByStatus = (
  params: FindPetsByStatusParams,
  signal?: AbortSignal,
) => {
  return kyMutator<Pet[]>({
    url: `/pet/findByStatus`,
    method: 'GET',
    params,
    signal,
  });
};

export const getFindPetsByStatusQueryKey = (
  params?: FindPetsByStatusParams,
) => {
  return [`/pet/findByStatus`, ...(params ? [params] : [])] as const;
};

export const getFindPetsByStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPetsByStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindPetsByStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findPetsByStatus>>
  > = ({ signal }) => findPetsByStatus(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findPetsByStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindPetsByStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByStatus>>
>;
export type FindPetsByStatusQueryError = void;

export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void,
>(
  params: FindPetsByStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPetsByStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPetsByStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPetsByStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Finds Pets by status
 */

export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = void,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPetsByStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindPetsByStatusQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @deprecated
 * @summary Finds Pets by tags
 */
export const findPetsByTags = (
  params: FindPetsByTagsParams,
  signal?: AbortSignal,
) => {
  return kyMutator<Pet[]>({
    url: `/pet/findByTags`,
    method: 'GET',
    params,
    signal,
  });
};

export const getFindPetsByTagsQueryKey = (params?: FindPetsByTagsParams) => {
  return [`/pet/findByTags`, ...(params ? [params] : [])] as const;
};

export const getFindPetsByTagsQueryOptions = <
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByTagsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByTags>>> = ({
    signal,
  }) => findPetsByTags(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findPetsByTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindPetsByTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByTags>>
>;
export type FindPetsByTagsQueryError = void;

export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void,
>(
  params: FindPetsByTagsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @deprecated
 * @summary Finds Pets by tags
 */

export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = void,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindPetsByTagsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a single pet
 * @summary Find pet by ID
 */
export const getPetById = (petId: number, signal?: AbortSignal) => {
  return kyMutator<Pet>({ url: `/pet/${petId}`, method: 'GET', signal });
};

export const getGetPetByIdQueryKey = (petId?: number) => {
  return [`/pet/${petId}`] as const;
};

export const getGetPetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = void,
>(
  petId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPetByIdQueryKey(petId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPetById>>> = ({
    signal,
  }) => getPetById(petId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!petId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPetById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPetById>>
>;
export type GetPetByIdQueryError = void;

export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = void,
>(
  petId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = void,
>(
  petId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = void,
>(
  petId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Find pet by ID
 */

export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = void,
>(
  petId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPetByIdQueryOptions(petId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates a pet in the store with form data
 */
export const updatePetWithForm = (
  petId: number,
  updatePetWithFormBody: UpdatePetWithFormBody,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (updatePetWithFormBody.name !== undefined) {
    formUrlEncoded.append(`name`, updatePetWithFormBody.name);
  }
  if (updatePetWithFormBody.status !== undefined) {
    formUrlEncoded.append(`status`, updatePetWithFormBody.status);
  }

  return kyMutator<unknown>({
    url: `/pet/${petId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    data: formUrlEncoded,
    signal,
  });
};

export const getUpdatePetWithFormMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePetWithForm>>,
  TError,
  { petId: number; data: UpdatePetWithFormBody },
  TContext
> => {
  const mutationKey = ['updatePetWithForm'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    { petId: number; data: UpdatePetWithFormBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return updatePetWithForm(petId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePetWithFormMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePetWithForm>>
>;
export type UpdatePetWithFormMutationBody = UpdatePetWithFormBody;
export type UpdatePetWithFormMutationError = void;

/**
 * @summary Updates a pet in the store with form data
 */
export const useUpdatePetWithForm = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePetWithForm>>,
      TError,
      { petId: number; data: UpdatePetWithFormBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePetWithForm>>,
  TError,
  { petId: number; data: UpdatePetWithFormBody },
  TContext
> => {
  const mutationOptions = getUpdatePetWithFormMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Deletes a pet
 */
export const deletePet = (petId: number) => {
  return kyMutator<unknown>({ url: `/pet/${petId}`, method: 'DELETE' });
};

export const getDeletePetMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePet>>,
    TError,
    { petId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePet>>,
  TError,
  { petId: number },
  TContext
> => {
  const mutationKey = ['deletePet'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePet>>,
    { petId: number }
  > = (props) => {
    const { petId } = props ?? {};

    return deletePet(petId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePetMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePet>>
>;

export type DeletePetMutationError = void;

/**
 * @summary Deletes a pet
 */
export const useDeletePet = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePet>>,
      TError,
      { petId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deletePet>>,
  TError,
  { petId: number },
  TContext
> => {
  const mutationOptions = getDeletePetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 */
export const getInventory = (signal?: AbortSignal) => {
  return kyMutator<GetInventory200>({
    url: `/store/inventory`,
    method: 'GET',
    signal,
  });
};

export const getGetInventoryQueryKey = () => {
  return [`/store/inventory`] as const;
};

export const getGetInventoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInventoryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventory>>> = ({
    signal,
  }) => getInventory(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventory>>
>;
export type GetInventoryQueryError = unknown;

export function useGetInventory<
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventory>>,
          TError,
          Awaited<ReturnType<typeof getInventory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetInventory<
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventory>>,
          TError,
          Awaited<ReturnType<typeof getInventory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetInventory<
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Returns pet inventories by status
 */

export function useGetInventory<
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventory>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInventoryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Place an order for a pet
 */
export const placeOrder = (order: Order, signal?: AbortSignal) => {
  return kyMutator<Order>({
    url: `/store/order`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: order,
    signal,
  });
};

export const getPlaceOrderMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof placeOrder>>,
    TError,
    { data: Order },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof placeOrder>>,
  TError,
  { data: Order },
  TContext
> => {
  const mutationKey = ['placeOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof placeOrder>>,
    { data: Order }
  > = (props) => {
    const { data } = props ?? {};

    return placeOrder(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaceOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof placeOrder>>
>;
export type PlaceOrderMutationBody = Order;
export type PlaceOrderMutationError = void;

/**
 * @summary Place an order for a pet
 */
export const usePlaceOrder = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof placeOrder>>,
      TError,
      { data: Order },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof placeOrder>>,
  TError,
  { data: Order },
  TContext
> => {
  const mutationOptions = getPlaceOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
 * @summary Find purchase order by ID
 */
export const getOrderById = (orderId: number, signal?: AbortSignal) => {
  return kyMutator<Order>({
    url: `/store/order/${orderId}`,
    method: 'GET',
    signal,
  });
};

export const getGetOrderByIdQueryKey = (orderId?: number) => {
  return [`/store/order/${orderId}`] as const;
};

export const getGetOrderByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = void,
>(
  orderId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({
    signal,
  }) => getOrderById(orderId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!orderId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrderById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetOrderByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrderById>>
>;
export type GetOrderByIdQueryError = void;

export function useGetOrderById<
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = void,
>(
  orderId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetOrderById<
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = void,
>(
  orderId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetOrderById<
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = void,
>(
  orderId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Find purchase order by ID
 */

export function useGetOrderById<
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = void,
>(
  orderId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetOrderByIdQueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
 * @summary Delete purchase order by ID
 */
export const deleteOrder = (orderId: number) => {
  return kyMutator<unknown>({
    url: `/store/order/${orderId}`,
    method: 'DELETE',
  });
};

export const getDeleteOrderMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrder>>,
    TError,
    { orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteOrder>>,
  TError,
  { orderId: number },
  TContext
> => {
  const mutationKey = ['deleteOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrder>>,
    { orderId: number }
  > = (props) => {
    const { orderId } = props ?? {};

    return deleteOrder(orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOrder>>
>;

export type DeleteOrderMutationError = void;

/**
 * @summary Delete purchase order by ID
 */
export const useDeleteOrder = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteOrder>>,
      TError,
      { orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteOrder>>,
  TError,
  { orderId: number },
  TContext
> => {
  const mutationOptions = getDeleteOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithListInput = (
  userArrayBody: UserArrayBody,
  signal?: AbortSignal,
) => {
  return kyMutator<void>({
    url: `/user/createWithList`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userArrayBody,
    signal,
  });
};

export const getCreateUsersWithListInputMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUsersWithListInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationKey = ['createUsersWithListInput'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithListInput(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUsersWithListInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithListInput>>
>;
export type CreateUsersWithListInputMutationBody = UserArrayBody;
export type CreateUsersWithListInputMutationError = void;

/**
 * @summary Creates list of users with given input array
 */
export const useCreateUsersWithListInput = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUsersWithListInput>>,
      TError,
      { data: UserArrayBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUsersWithListInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationOptions = getCreateUsersWithListInputMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get user by user name
 */
export const getUserByName = (username: string, signal?: AbortSignal) => {
  return kyMutator<User>({ url: `/user/${username}`, method: 'GET', signal });
};

export const getGetUserByNameQueryKey = (username?: string) => {
  return [`/user/${username}`] as const;
};

export const getGetUserByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = void,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByNameQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByName>>> = ({
    signal,
  }) => getUserByName(username, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserByName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetUserByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserByName>>
>;
export type GetUserByNameQueryError = void;

export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = void,
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = void,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = void,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get user by user name
 */

export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = void,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetUserByNameQueryOptions(username, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export const updateUser = (username: string, user: User) => {
  return kyMutator<unknown>({
    url: `/user/${username}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: user,
  });
};

export const getUpdateUserMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { username: string; data: User },
  TContext
> => {
  const mutationKey = ['updateUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { username: string; data: User }
  > = (props) => {
    const { username, data } = props ?? {};

    return updateUser(username, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type UpdateUserMutationBody = User;
export type UpdateUserMutationError = void;

/**
 * @summary Updated user
 */
export const useUpdateUser = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { username: string; data: User },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { username: string; data: User },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export const deleteUser = (username: string) => {
  return kyMutator<unknown>({ url: `/user/${username}`, method: 'DELETE' });
};

export const getDeleteUserMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationKey = ['deleteUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return deleteUser(username);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;

export type DeleteUserMutationError = void;

/**
 * @summary Delete user
 */
export const useDeleteUser = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { username: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Logs user into the system
 */
export const loginUser = (params: LoginUserParams, signal?: AbortSignal) => {
  return kyMutator<string>({
    url: `/user/login`,
    method: 'GET',
    params,
    signal,
  });
};

export const getLoginUserQueryKey = (params?: LoginUserParams) => {
  return [`/user/login`, ...(params ? [params] : [])] as const;
};

export const getLoginUserQueryOptions = <
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = void,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLoginUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof loginUser>>> = ({
    signal,
  }) => loginUser(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof loginUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type LoginUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof loginUser>>
>;
export type LoginUserQueryError = void;

export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = void,
>(
  params: LoginUserParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = void,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = void,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Logs user into the system
 */

export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = void,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getLoginUserQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Logs out current logged in user session
 */
export const logoutUser = (signal?: AbortSignal) => {
  return kyMutator<void>({ url: `/user/logout`, method: 'GET', signal });
};

export const getLogoutUserQueryKey = () => {
  return [`/user/logout`] as const;
};

export const getLogoutUserQueryOptions = <
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({
    signal,
  }) => logoutUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logoutUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type LogoutUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof logoutUser>>
>;
export type LogoutUserQueryError = void;

export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Logs out current logged in user session
 */

export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getLogoutUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithArrayInput = (
  userArrayBody: UserArrayBody,
  signal?: AbortSignal,
) => {
  return kyMutator<void>({
    url: `/user/createWithArray`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userArrayBody,
    signal,
  });
};

export const getCreateUsersWithArrayInputMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationKey = ['createUsersWithArrayInput'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithArrayInput(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUsersWithArrayInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>
>;
export type CreateUsersWithArrayInputMutationBody = UserArrayBody;
export type CreateUsersWithArrayInputMutationError = void;

/**
 * @summary Creates list of users with given input array
 */
export const useCreateUsersWithArrayInput = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUsersWithArrayInput>>,
      TError,
      { data: UserArrayBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationOptions = getCreateUsersWithArrayInputMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export const createUser = (user: User, signal?: AbortSignal) => {
  return kyMutator<void>({
    url: `/user`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: user,
    signal,
  });
};

export const getCreateUserMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: User },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: User },
  TContext
> => {
  const mutationKey = ['createUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: User }
  > = (props) => {
    const { data } = props ?? {};

    return createUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type CreateUserMutationBody = User;
export type CreateUserMutationError = void;

/**
 * @summary Create user
 */
export const useCreateUser = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: User },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: User },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
